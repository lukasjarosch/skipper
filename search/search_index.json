{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#skipper","title":"Skipper","text":""},{"location":"#what-is-skipper","title":"What is Skipper?","text":"<p>Skipper is a library which helps you to manage complex configuration and enables you to use your large data-set inside templates. Having one - central - set of agnostic configuration files will make managing your clusters, infrastrucutre stages, etc. much easier. You can rely on  the inventory of data, modify it to target-specific needs, use the data in  templates, and be sure that whatever you're generating is always in sync with your inventoyu. Whether you generate only a single file, or manage multi-stage multi-region infrastructure deployments doesn't matter. Skipper is a library which enables you to easily build your own - company or project specific - configuration management.</p> <p>Skipper is heavily inspired by the Kapitan project. The difference is that skipper is a library which does not make any assumptions of your needs (aka. not opinionated).  This allows you for example to have way more control over how you want to process your inventory.</p> <p>Skipper is not meant to be a one-size-fits-all solution. The goal of Skipper is to enable you to create the own - custom built - template and inventory engine, without having to do the heavy lifing.</p>"},{"location":"#values","title":"Values","text":"<ul> <li>Skipper wants you to abstract away all the information at your disposal - before thinking about the technologies used</li> <li>Infrastructure/Code/Documentation/Bootstraping/... is just an aggregation of information you should already have</li> <li>Skipper helps you to aggregate, cumulate and leverage your information to build the next big thing.</li> <li>Secret management should not be hard, it should be automatic. Skipper has got you covered!</li> </ul> <p>Skipper is a library which does the heavy lifting. Creating something awesome is up to you !</p>"},{"location":"concepts/inventory/classes/","title":"Classes","text":"<p>A class is just any arbitrary yaml file with a few rules attached. For the most part you are free to do whatever you want inside a class.</p> <p>Think of classes as building-blocks which describe different aspects of your project.</p>"},{"location":"concepts/inventory/classes/#class-rules","title":"Class Rules","text":"<p>In order for your inventory to be maintainable by Skipper, there are a few - very basic - rules which you need to comply.</p> <ol> <li>There can only be one root key inside the class</li> <li>The root key must match the filename of your class. A class <code>project.yaml</code> is expected to use <code>project</code> as root key.</li> <li>The class cannot be called <code>target.yaml</code></li> </ol>"},{"location":"concepts/inventory/classes/#example-use-case","title":"Example Use-case","text":"<p>You got yourself a little project where you need to setup some cloud resources, nice!</p> <ul> <li>You want to use terraform (at least for now, maybe you need to switch in the future)</li> <li>You want to store the terraform state remotely</li> <li>You want to have a script which bootstraps the storage of your state</li> <li>You need various deployments of the same infrastructure (dev, staging, production, qa, ...)</li> </ul> <p>We're not going down the rabbit-hole why generating terraform code is inhertently a better idea than to write it manually, just roll with it for now. If you're really curious, check out this short summary by Eden Reich.</p>"},{"location":"concepts/inventory/data/","title":"Data","text":"<p>This datatype is heavily used within Skipper. Although it is exposed via the API, you will most likely not  have to work with it in the beginning. It may help to understand this core feature of Skipper though.</p> <p>The Data type is the core datatype used throughout skipper. It is the result of unmarshalling arbitrary yaml data and having the requirement to work with it in classes or targets. In essence, it is just a <code>map[string]interface{}</code> with some attached functionality.</p> <p>The functionality of the Data map is rather simple, yet powerful. In essence, one can do the following:</p> <ul> <li>Get a value from the map using a path</li> <li>Set a value given a path </li> <li>Merge two <code>Data</code> maps, following basic rules.</li> <li>Recursively find values</li> </ul>"},{"location":"concepts/inventory/data/#paths","title":"Paths","text":"<p>If you're familiar with jq or yq, then you already know what paths are. Although, the paths in Skipper are not as powerful, they get the job done.</p> <p>A path is a unique identifier of a specific value inside Skipper (say: a yaml file).</p> <p>Instead of telling you how paths are created, let's consider the following example to show you.</p> Example yaml file<pre><code>---\nexample:\n  foo: bar\n  food:\n    - name: \"pizza\" \n      rating: 10\n    - name: \"salad\"\n      rating: 2\n  array:\n    - one\n    - two\n    - three\n</code></pre> <p>In order to identify specific values inside this yaml file, the following paths could be used:</p> <ul> <li><code>example.foo</code> points to bar</li> <li><code>example.food.0.name</code> points to pizza</li> <li><code>example.array.1</code> points to two</li> </ul> <p>That's pretty much how paths work, there is not much more to know about them.  Paths are just the plain identifiers and do not support any modifiers. They are only used to point to data which you're interested in.</p> <p>These paths are what enables the use of variables, calls and secrets by uniquely identifying a specific value inside your inventory.</p>"},{"location":"concepts/inventory/data/#get-and-set-values","title":"Get and Set values","text":"<p>Getting and setting values inside <code>Data</code> is obviously required. It leverages the paths to reference inside the map.</p> <pre><code>@startyaml\n#highlight \"example\" / \"food\" / \"0\" / \"name\"\nexample:\n  foo: bar\n  food:\n    - name: \"pizza\" \n      rating: 10\n    - name: \"salad\"\n      rating: 2\n  array:\n    - one\n    - two\n    - three\n@endyaml\n</code></pre>"},{"location":"concepts/inventory/data/#merge","title":"Merge","text":""},{"location":"concepts/inventory/data/#find-values","title":"Find values","text":""},{"location":"concepts/inventory/overview/","title":"Overview","text":"<p>The inventory is the core of every Skipper project. It is basically just a set of user-defined <code>yaml</code> files with some special rules attached. These yaml files can be composed in order to produce a final inventory which you can use inside templates to compile your desired target infrastructure.</p> <p>Below is an overview of all the components which make up Skipper, and how they might interact with one-another.</p> <p></p>"},{"location":"concepts/inventory/overview/#classes","title":"Classes","text":"<p>Classes are YAML files in which you can define information about every aspect of your project. Classes become your building blocks, your source of truth and therefore the heart of your project.</p>"},{"location":"concepts/inventory/overview/#targets","title":"Targets","text":"<p>A target represents an instance of your project. Targets are defined with YAML files as well. They use skipper-keywords to include classes which are relevant for that instance. The combination of the used classes and what is defined inside a target, is the data you can use inside templates.</p>"},{"location":"concepts/inventory/overview/#variables","title":"Variables","text":"<p>Variables are used to reference values inside your inventory. Once data is formalized in classes, you can reference that data from other classes without the need to redefine it. Connecting your data through variables is a very powerful way to represent business rules  and makes refactoring a bliss.</p>"},{"location":"concepts/inventory/overview/#calls","title":"Calls","text":"<p>Sometimes the data you have needs to be transformed before it becomes useful inside templates. With calls you can modify the data before it reaches the templates. Maybe a specific value cannot be hardcoded into classes, then it might be useful to load it from an environment variable for example.</p>"},{"location":"concepts/inventory/overview/#secrets","title":"Secrets","text":"<p>Secret management should not be a pain. Ideally secrets are also versioned along your inventory. But storing secrets inside git is bad practice you say?  Not with Skipper's secret management. Secrets are encrypted files which you can simply commit. Only once the secrets are actually needed (e.g. inside a CI job), they are decrypted temporarily.</p>"},{"location":"concepts/inventory/overview/#templates","title":"Templates","text":"<p>Templates (Skipper is using go templates) have access to your target and classes. You can build generic templates and aggregate your data into it, without having to re-write files for different stages. Having a documentation, specific to an instance (stage) of your project, can be quite useful and is easy to implement with Skipper.</p>"},{"location":"concepts/inventory/variables/dynamic/","title":"Dynamic Variables","text":"<p>Dynamic variables are references into your data inventory. They are immensly useful to compose data into more complex values without having to redefine stuff all over the place.</p>"},{"location":"concepts/inventory/variables/dynamic/#local-referencing-variables","title":"Local-referencing variables","text":"myClass.yaml<pre><code>myClass:\n    foo: bar\n    bar: \n        - baz\n        - world\n    hello: ${bar:1} \n</code></pre>"},{"location":"concepts/inventory/variables/dynamic/#absolute-referencing-variables","title":"Absolute-referencing variables","text":""},{"location":"concepts/inventory/variables/overview/","title":"Overview","text":"<p>Variables allow you to use data which is not (yet) defined or reference data which is defined somewhere else.</p> <p>In Skipper, there are three types of variables:</p> <ol> <li>Dynamic Variables are used to reference data in the inventory.</li> <li>Static Variables are built into your binary which uses skipper, hence they are known at compile-time.</li> <li>User-Defined Variables are defined and referenced custom values in the inventory.</li> </ol>"},{"location":"concepts/inventory/variables/overview/#format","title":"Format","text":"<p>The format of variables is <code>${variable_name}</code>. It can be used in Classes and Targets.</p> <p>The regex used to match variables is: <code>\\$\\{((\\w*)(\\:\\w+)*)\\}</code></p>"},{"location":"concepts/secrets/drivers/azurekv/","title":"Azure KeyVault","text":""},{"location":"concepts/templates/overview/","title":"Templates - Overview","text":""}]}